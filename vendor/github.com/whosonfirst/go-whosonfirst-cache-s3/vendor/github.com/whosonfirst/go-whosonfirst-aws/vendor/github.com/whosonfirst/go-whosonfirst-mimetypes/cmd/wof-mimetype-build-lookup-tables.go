package main

import (
	"bufio"
	"flag"
	"io"
	"log"
	"os"
	"regexp"
	"sort"
	"strings"
	"text/template"
	"time"
)

var re_lookup *regexp.Regexp

func init() {

	re, err := regexp.Compile(`\s{2,}|\t{1,}`)

	if err != nil {
		log.Fatal(err)
	}

	re_lookup = re
}

func in_array(needle string, haystack []string) bool {

	sort.Strings(haystack)

	i := sort.Search(len(haystack), func(i int) bool { return haystack[i] >= needle })

	if i < len(haystack) && haystack[i] == needle {
		return true
	}

	return false
}

func parse(fh io.Reader, lookup_type string, lookup_table map[string][]string) map[string][]string {

	scanner := bufio.NewScanner(fh)

	for scanner.Scan() {

		ln := scanner.Text()

		if strings.HasPrefix(ln, "#") {
			continue
		}

		ln = re_lookup.ReplaceAllString(ln, " ")
		parts := strings.Split(ln, " ")

		key := parts[0]
		values := parts[1:]

		switch lookup_type {
		case "mimetype":

			_, ok := lookup_table[key]

			if ok {

				for _, v := range values {

					if in_array(v, lookup_table[key]) {
						continue
					}

					lookup_table[key] = append(lookup_table[key], v)
				}

			} else {
				lookup_table[key] = values
			}

		case "extension":

			for _, v := range values {

				_, ok := lookup_table[v]

				if ok {

					if in_array(key, lookup_table[v]) {
						continue
					}

					lookup_table[v] = append(lookup_table[v], key)
				} else {
					lookup_table[v] = []string{key}
				}
			}

		default:
			// we should never get here
		}
	}

	return lookup_table
}

func render(writer io.Writer, lookup_var string, lookup_table map[string][]string) error {

	tpl := `package lookup

// This file was generated by robots on {{ .LastModified }}

var By{{ .LookupVar }} = map[string][]string{
	{{ range $k, $v := .LookupTable}}"{{ $k }}": []string{ {{ range $vv := $v }}"{{ $vv }}",{{ end }} },
	{{ end }}
}`

	t := template.New("lookup")
	t, err := t.Parse(tpl)

	if err != nil {
		return err
	}

	now := time.Now()
	lastmod := now.Format(time.RFC3339)

	vars := struct {
		LastModified string
		LookupVar    string
		LookupTable  map[string][]string
	}{
		LastModified: lastmod,
		LookupVar:    lookup_var,
		LookupTable:  lookup_table,
	}

	return t.Execute(os.Stdout, vars)
}

func main() {

	var lookup = flag.String("lookup", "extension", "")

	flag.Parse()

	switch *lookup {
	case "extension":
		// pass
	case "mimetype":
		// pass
	default:
		log.Fatal("Invalid lookup type")
	}

	// build lookup tables

	lookup_table := make(map[string][]string)

	for _, table := range flag.Args() {

		fh, err := os.Open(table)

		if err != nil {
			log.Fatal(err)
		}

		defer fh.Close()

		lookup_table = parse(fh, *lookup, lookup_table)
	}

	// output

	lookup_var := strings.ToTitle(*lookup)
	writer := os.Stdout

	err := render(writer, lookup_var, lookup_table)

	if err != nil {
		log.Fatal(err)
	}

	os.Exit(0)
}
